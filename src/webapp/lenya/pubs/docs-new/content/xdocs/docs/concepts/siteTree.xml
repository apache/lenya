<?xml version="1.0"?>
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V1.1//EN" "document-v11.dtd">
<document> 
  <header> 
    <title>Site Tree</title>
    <version major="0" minor="1">Initial version</version>
    <authors>
      <person name="Christian Egli" email="christian.egli@wyona.org"/>
    </authors> 
    <notice></notice> 
    <abstract>Proposal for a a general framework for management of
    navigation for a publication.</abstract> 
  </header> 
  <body> 

    <section>
      <title>Motivation</title>

      <p>Currently there is no standard way to manage the navigation
in Lenya. Previous attempts have shown their own merits and
drawbacks. A general and standard approach is needed.</p>

    </section>

    <section>
      <title>Rationale</title>

      <p>The basic problems we're trying to solve are as follows:</p>
      <ol>
	<li>Maintain the navigation in an easy format independent of
	the actual storage of the documents.</li> 
	<li>Enable moving of documents.</li>
	<li>Enable querying of doctype independent of request URI.</li>
      </ol>

      <section>
	<title>Navigation</title>
	
	<p>There are a couple of known implementations to choose from:</p>
	<ul>
	  <li>The existing Lenya tree.xml</li> 
	  <li>The Forrest site.xml.</li>
	  <li>The hashmap way: A sitetree.xml and purlspace.xml combination
   where the purlspace.xml contains all existing documents and
   sitetree.xml contains the navigation hierarchy.</li>
	</ul>
      </section>

      <section>
	<title>Moving Of Documents</title>
	
	<p>The Forrest site.xml solves this quite elegantly: Due to the use of
XPath and some ambiguity the documents can be found almost
independent of their actual location</p>

	<p>With the existing Lenya or the hashmap solution changing of document
location requires editing of the tree.xml or the purlspace.xml
respectively.</p>
      </section>

      <section>
	<title>Doctype Querying</title>
	
	<p>For question 3 there are a couple of known approaches:</p>

	<section>
	  <title>Hashmap</title>
	  <p>This method uses an action which contains for each
   request URI a mapping to attributes such as doctype, srcfile, xslt,
   etc.</p>
	</section>
	<section>
	  <title>Forrest SourceTypeAction</title>
	  <p>Forrest contains an action which for a given request
   opens the source file and determines its doctype based on the dtd
   declaration.</p>
	</section>
	<section>
	  <title>URIParametrizer</title>
	  <p>The URIParametrizer is a black box (probably an action)
   which internally issues cocoon requests to different sitemaps which
   return different attributes (doctype, etc.) for a given request
   URI.</p>
	  <p>This amounts to a combination of the hashmap solution
   with the basic cocoon concepts: The request URIs aren't matched
   against a hashmap but are handled by a sitemap instead. The sitemap
   contains normal pipelines and matchers which match on the
   request. As a catch-all there is still the possibility of using a
   hashmap for URIs that didn't match any pipelines.</p>
	  <p>Finally a new (internal) request is generated using the
   parameter values. This request is handled by a normal cocoon
   sitemap as if the original request had contained these
   parameters.</p>
	  <figure src="URIParametrizer.png" alt="Diagram of URIParametrizer"/>
	</section>
      </section>
    </section>

    <section>
      <title>Backwards Compatibility</title>
      <p>There has not been a previous implementation, so this is a non-issue.</p>
    </section>

    <section>
      <title>Roadmap</title>
      <ul>
	<li>Decide which solution to choose</li>
      </ul>
    </section>

    <section>
      <title>Reference Implementation</title>
      <p>None</p>
    </section>

  </body> 
  <footer> 
    <legal>Â© 2003 wyona.org</legal> 
  </footer>
</document>
