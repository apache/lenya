<?xml version="1.0" encoding="UTF-8"?>
<!--
  Copyright 1999-2006 The Apache Software Foundation

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<!-- $Id: metadata.xml 55543 2004-10-26 00:14:59Z gregor $ -->
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" 
  "http://forrest.apache.org/dtd/document-v20.dtd">
<document>
  <header>
    <title>Implementing a Usecase, Part 1: Prerequisites</title>
  </header>
  <body>
    
    <section>
      <title>Introduction</title>
      <p>
        In this tutorial we'll implement a simple user interaction scenario using
        the <a href="site:usecase-framework-overview">usecase framework</a>.
        The implementation will be based on the <em>person</em> resource type module described
        in the tutorial <a href="site:newResourceTypePart1">Creating a Resource Type</a>.
        We'll extend the resource type to include "knows" relationships. Our usecase will
        allow the connect a person to other people.
      </p>
      <p>
        To accomplish this task, we will
      </p>
      <ul>
        <li>Extend the person schema to support <code><![CDATA[<foaf:knows/>]]></code> elements,</li>
        <li>Implement a wrapper class to manage person documents,</li>
        <li>Add a usecase handler class to provide the functionality to connect people,</li>
        <li>
          Add a <a href="http://cocoon.apache.org/2.1/userdocs/flow/jxtemplate.html">JX template</a>
          which acts as the view for the usecase,
        </li>
        <li>Add a menu item to trigger the usecase, and</li>
        <li>Specify who is allowed to invoke the usecase.</li>
      </ul>
    </section>
    
    <section>
      <title>Add the "Knows" Relation to the Person Resource Type</title>
      <p>
        First, we'll add support for the <code><![CDATA[<foaf:knows/>]]></code> element to the
        Relax NG schema, which is located at <code>$MODULE_HOME/resources/schemas/foaf.rng</code>.
        We allow to specify the known person using an <code>rdf:resource</code> attribute, which
        can hold an internal <code>lenya-document:</code> URI.
      </p>
      <source xml:space="preserve"><![CDATA[<grammar ...>
  <start>
    <element name="rdf:RDF">
      <element name="foaf:Person">
        ...
        
        <zeroOrMore>
          <element name="foaf:knows">
            <attribute name="rdf:resource">
              <data type="anyURI"/>
            </attribute>
          </element>
        </zeroOrMore>
        
      </element>
    </element>
  </start>
</grammar>]]></source>
      
      <p>
        Now we need to extend our presentation layer to consider the "knows" relations.
        We use CInclude to lookup the person's name based on the <code>foaf:knows</code>
        element. This requires two steps: an XSLT preprocessing to add the CInclude element to
        the <code>foaf:knows</code> element, and the actual CInclude transformation.
        In the module sitemap, which is located at <code>$MODULE_HOME/sitemap.xmap</code>,
        add these steps to the presentation pipeline:
      </p>
      <source xml:space="preserve"><![CDATA[<!-- {format}.xml/{pubId}/{area}/{uuid}/{language} -->
<map:match pattern="*.*/*/*/*/*">
  <map:generate src="lenya-document:{5},lang={6}{link:rev}"/>
  <map:transform src="fallback://lenya/modules/person/xslt/knows2include.xsl"/>
  <map:transform type="cinclude"/>
  <map:transform src="fallback://lenya/modules/person/xslt/foaf2{1}.xsl">
  ...
</map:match>]]></source>
      <p>
        Now we add the XSLT which adds the CInclude statements. It is located at
        <code>$MODULE_HOME/xslt/knows2include.xsl</code>. The <code>src</code>
        attribute of the <code><![CDATA[<ci:include/>]]></code> element is set to the
        <code>rdf:resource</code> attribute, which holds a <code>lenya-document:</code> URI. 
      </p>
      <source xml:space="preserve"><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
  xmlns:foaf="http://xmlns.com/foaf/0.1/"
  xmlns:ci="http://apache.org/cocoon/include/1.0"
  >
  
  <xsl:template match="foaf:knows">
    <xsl:copy>
      <xsl:copy-of select="@*"/>
      <ci:include src="{@rdf:resource}"/>
    </xsl:copy>
  </xsl:template>
  
  <xsl:template match="@*|node()" priority="-1">
    <xsl:copy>
      <xsl:apply-templates select="@*|node()"/>
    </xsl:copy>
  </xsl:template>
  
</xsl:stylesheet>]]></source>
      
      <p>
        Finally, we have to include the known people in the output. We add a table row to
        the <code>$MODULE_HOME/xslt/foaf2xhtml.xsl</code> stylesheet:
      </p>
      <source xml:space="preserve"><![CDATA[<tr>
  <th>Knows:</th>
  <td>
    <xsl:for-each select="foaf:knows">
      <a href="{@rdf:resource}">
        <xsl:value-of select="rdf:RDF/foaf:Person/foaf:givenname"/>
        <xsl:text> </xsl:text>
        <xsl:value-of select="rdf:RDF/foaf:Person/foaf:family_name"/>
      </a>
      <br/>
    </xsl:for-each>
  </td>
</tr>]]></source>
      <p>
        To test this functionality, you can add two person documents to your
        publication, edit one of them using the one-form editor, and add the
        <code><![CDATA[<foaf:knows/>]]></code> element, pointing to the other
        person document, e.g.:
      </p>
      <source xml:space="preserve"><![CDATA[<foaf:knows rdf:resource="lenya-document:5e13b150-6855-11dc-8b37-f5f12a4217db"/>]]></source>
    </section>
    
    <section>
      <title>Implement the Person Document Wrapper</title>
      <p>
        In Lenya projects, the wrapper pattern (also known as adapter pattern) has proven
        useful to simplify the handling of XML documents. A wrapper object provides
        access to a certain object, in our case a Lenya document, to client objects. It can
        be used to add a layer of abstraction. In our case we use the wrapper to abstract
        from the XML content and provide the functionality of adding "knows" relations
        between person documents.
      </p>
      <p>
        The following code snippet contains some methods to illustrate the functionality
        of the Person class. For the full source code, check out the person module from the
        Subversion repository.
      </p>
      <p>
        We pass an <code>org.apache.lenya.cms.publication.Document</code>
        object to the constructor which stores the XML content describing the person.
        The <code>getName()</code> function returns the full name, i.e. the concatenation
        of the given name and the family name. This method will be used to show the person's
        name on the usecase view page. The <code>load()</code> and <code>save()</code> methods
        act as the persistence facilities of the person object.
      </p>
      <source xml:space="preserve"><![CDATA[public class Person extends AbstractLogEnabled {
        
    ...

    public Person(Document doc) {
        ...
    }

    public Person[] getKnownPeople() {
        load();
        Collection persons = this.knownPersons.values();
        return (Person[]) persons.toArray(new Person[persons.size()]);
    }

    public void addKnownPerson(Person person) {
        load();
        this.knownPersons.put(person.getDocument().getUUID(), person);
        save();
    }
    
    public String getName() {
        load();
        return this.givenName + " " + this.familyName;
    }

    ...

}]]></source>
    </section>
      
    <section>
      <title>Declaring the Usecase</title>
      <p>
        Now we're ready to start working on the actual usecase. First, we tell Lenya about
        the usecase. The usecase declaration is a patch file for <code>cocoon.xconf</code>.
        It is located at <code>$MODULE_HOME/config/cocoon-xconf/usecase-addKnownPerson.xconf</code>.
        It adds the <em>person.addKnownUsecase</em> usecase component instance if it doesn't
        exist yet (determined by the <code>unless</code> attribute):
      </p>
      <source xml:space="preserve"><![CDATA[<xconf xpath="/cocoon/usecases"
  unless="/cocoon/usecases/component-instance[@name = 'person.addKnownPerson']">
  
  <component-instance name="person.addKnownPerson" logger="lenya.modules.person"
      class="org.apache.lenya.modules.person.usecases.AddKnownPerson">
    <view template="modules/person/usecases/addKnownPerson.jx"/>
  </component-instance>
  
</xconf>
]]></source>
      <p>
        This usecase declaration specifies the usecase handler class (in our case
        <code>AddKnownPerson</code>) and the JX template which acts as the view for
        the usecase (<code>addKnownPerson.jx</code>). For a complete list of the generic
        usecase configuration options, refer to the <a href="site:abstractusecase">AbstractUsecase</a>
        documentation.
      </p>
    </section>
    
    <section>
      <title>Implementing the Usecase Handler Class</title>
      <p>
        The usecase handler object receives user input and manipulates the business objects,
        in our case the <code>Person</code> objects, accordingly. It has the following
        responsibilities:
      </p>
      <ul>
        <li>Prepare data to be displayed on the view,</li>
        <li>Validate user input and generate appropriate error messages, and</li>
        <li>Manipulate the business objects.</li>
      </ul>
      <p>
        If you want to follow a strictly object-oriented approach, the usecase handler class
        itself shouldn't contain any knowledge about the business logic. It belongs to the
        controller part of the <acronym title="Model-View-Controller">MVC</acronym> pattern
        (the other parts of the controller are the usecase sitemap and the flowscript).
      </p>
      <p>
        The following code snippet shows the usecase handler class.
        At this point, we implement only the two most important methods:
      </p>
      <ul>
        <li>
          <code>initParameters()</code> initializes the usecase parameters which are
          used to communicate between the usecase handler and the view. In our case, it
          compiles a list of <code>Person</code> objects, one for each document with the resource type
          <em>person</em>.
        </li>
        <li>
          <code>doExecute()</code> gets the <em>uuid</em> parameter from the view and adds
          the corresponding <code>Person</code> object to the list of known people.
        </li>
      </ul>
      <source xml:space="preserve"><![CDATA[public class AddKnownPerson extends DocumentUsecase {

    protected void initParameters() {
        super.initParameters();

        Document doc = getSourceDocument();
        Document[] allDocs = doc.area().getDocuments();

        try {
            Set peopleDocs = new HashSet();
            for (int i = 0; i < allDocs.length; i++) {
                if (allDocs[i].getResourceType().getName().equals("person")) {
                    Person person = new Person(allDocs[i]);
                    peopleDocs.add(person);
                }
            }
            setParameter("people", peopleDocs);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    protected void doExecute() throws Exception {
        super.doExecute();

        String uuid = getParameterAsString("uuid");
        Document doc = getSourceDocument();
        Person person = new Person(doc);

        Document knownDoc = doc.area().getDocument(uuid, doc.getLanguage());
        Person knownPerson = new Person(knownDoc);

        person.addKnownPerson(knownPerson);
    }

}]]></source>
    </section>
    
    <section>
      <title>Implementing the View</title>
      <p>
        We're using a JX template to implement the view. It allows us to generate XHTML
        code using properties of Java objects which are passed as parameters from the usecase
        handler object.
      </p>
      <p>
        The page contains a form, passing the <em>lenya.usecase</em> and <em>lenya.continuation</em>
        parameters as hidden input fields. We choose POST as the form method because we want
        to manipulate data on the server, avoiding that the user submits the form multiple times.
        We generate a drop-down list containing an option for each person,
        using the UUID as the <code>value</code> attribute of the <code>option</code> element.
        Remember that the <em>people</em> parameter was set in the <code>initParameters()</code>
        method of the usecase handler class.
      </p>
      <source xml:space="preserve"><![CDATA[<page:page xmlns:jx="http://apache.org/cocoon/templates/jx/1.0" 
           xmlns:page="http://apache.org/cocoon/lenya/cms-page/1.0" 
           xmlns="http://www.w3.org/1999/xhtml" 
           xmlns:i18n="http://apache.org/cocoon/i18n/2.1" >

  <page:title>
    <i18n:text>Add Known Person</i18n:text>
  </page:title>
  <page:body>
    
    <jx:import uri="fallback://lenya/modules/usecase/templates/messages.jx"/>
    
    <form method="POST">
      <input type="hidden" name="lenya.usecase" value="${usecase.getName()}"/>
      <input type="hidden" name="lenya.continuation" value="${continuation.id}"/>
      
      <p>
        <i18n:text>Select a person you know:</i18n:text>
      </p>
      <p>
        <select name="uuid">
          <jx:forEach var="person" items="${usecase.getParameter('people')}">
            <option value="${person.getDocument().getUUID()}">
              <jx:out value="${person.getName()}"/>
            </option>
          </jx:forEach>
        </select>
      </p>
  
      <p>
        <input i18n:attr="value" name="submit" type="submit" value="Submit"/>
        <i18n:text> </i18n:text>
        <input i18n:attr="value" name="cancel" type="submit" value="Cancel"/>
      </p>
      
    </form>
  </page:body>
</page:page>]]></source>
    </section>
    
    <section>
      <title>Adding the Menu Item</title>
    </section>
    
    <section>
      <title>What's Next?</title>
    </section>
    
  </body>
</document>
