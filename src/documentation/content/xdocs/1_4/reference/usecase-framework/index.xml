<?xml version="1.0" encoding="UTF-8"?>
<!--
  Copyright 2002-2004 The Apache Software Foundation

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" "http://forrest.apache.org/dtd/document-v20.dtd">
<document> 
  <header> 
    <title>The Usecase Framework</title> 
  </header>
  <body>
    
    <section>
      <title>Introduction</title>
      <p>A usecase in Lenya means a user triggered action. In most cases, a usecase is triggered by a CMS menu option on
      a specific document of the publication. This document is the object of the usecases' action (such as edit, delete, publish, ...).</p>
      <p>There are usecases which are independent of a specific document, such as the <code>ac.logout</code> usecase. In that case it does 
      not matter on what document the usecase is triggered. The part of the request which specifies the document is simply ignored
      by usecases that are document independent.</p>
      <p>The CMS menus trigger usecases by setting the <code>lenya.usecase</code> request parameter on the current document. If for example
      the user selects the <em>Publish</em> option from the <em>Workflow</em> menu, a request will be triggered such as:
      
<code>
      GET http://www.server.com/lenya/default/authoring/tutorial.html?&amp;lenya.usecase=publish
</code></p>
      <p>The Lenya <code>global-sitemap.xmap</code> will redirect requests with a <code>lenya.usecase</code> request parameter to the 
      <code>$LENYA_WEBAPP/lenya/usecase.xmap</code>
      sub-sitemap. From version 1.4 on, the following pipeline in this sitemap is used to recognonize usecases which are implemented 
      in Java using the new 1.4 usecase framework:</p>
<source xml:space="preserve"><![CDATA[
<map:pipeline>
  <map:match type="registered-usecase">
    <map:mount src="usecases/usecase.xmap" uri-prefix="" check-reload="yes" reload-method="synchron"/>
  </map:match>
</map:pipeline>]]>
</source>
	<p>The <code>registered-usecase</code> matcher's default implementation 
	(<code>org.apache.lenya.cms.cocoon.matching.UsecaseRegistrationMatcher</code>) will use the Avalon
	component resolver mechanism to resolve the name of the usecase to a an Avalon component. In case it cannot
	resolve the usecase to an Avalon component, sitemap processing will continue and the usecase is treated in the
	traditional way using the <code>usecase</code> and <code>step</code> matchers 
	(<code>org.apache.cocoon.matching.WildcardRequestParameterMatcher</code>). In order for this to work
	correctly, there should be a <code>lenya.step</code> parameter in the request.</p>
	<p>If the usecase could be resolved successfully into an Avalon component, processing will continue in the 
	<code>$LENYA_WEBAPP/lenya/usecases/usecase.xmap</code> (as opposed to <code>$LENYA_WEBAPP/lenya/usecase.xmap</code>) with
	the new JX and Java based 1.4 usecase framework.</p>
      <p>
        The <em>usecase framework</em> in Lenya 1.4 is a simple framework to implement usecases using JX templates and Java.
        This approach is an "85% solution". It enables the user to implement a big range of common usecases.
      </p>
      <note>
        Some special complex usecases might require a custom flowscript, in this case you can't use this framework.
      </note>
    </section>
    
    <section>
      <title>Directory Structure</title>
      
      <section>
        <title>The Lenya Core</title>
<source xml:space="preserve">
$LENYA_WEBAPP
  /lenya/usecases                     usecase-related files
                 /usecase.xmap        usecase dispatching sitemap
                 /usecases.js         flowscript for usecase control flow
                 /admin               Lenya admin usecases
                       /addUser.jx    JX templates for usecase views
                 ...                  more Lenya core usecases
</source>
      </section>
      
       <section>
        <title>Your Publication</title>
<source xml:space="preserve">
$PUB_HOME
  /lenya/usecases                     usecase-related files
                 /editHeadline.jx     JX templates for usecase views
  /java/src/...                       usecase handler classes
</source>
      </section>
      
    </section>
    
    
    <section>
      <title>Architecture</title>
      <p>
        A usecase request - denoted by the request parameter <code>lenya.usecase</code> - is dispatched by <code>$LENYA_WEBAPP/lenya/usecases/usecase.xmap</code>.
        All usecases are handled by a single flowscript <code>$LENYA_WEBAPP/lenya/usecases/usecases.js</code>. This keeps javascript maintenance costs at a minimum.
      </p>
      <p>
        The flowscript <code>usecases.js</code> determines the usecase handler class using the <code>org.apache.lenya.cms.usecase.UsecaseResolver</code>.
        All business code operations are delegated to the usecase handler class.
      </p>
      <figure src="site:usecase-framework-architecture.img" alt="Usecase framework architecture"/>

    </section>
    
    <section>
      <title>The Contract Between Flowscript And Usecase Handler</title>
      <p>
        The usecase handler class has to implement the interface <code>org.apache.lenya.cms.usecase.Usecase</code>.
        The methods of this interface are called in a certain order when the usecase is invoked:
      </p>
      <ol>
        <li><code>setSourceURL(String sourceUrl)</code>
            <br/>
            <code>setName(String)</code>
          <p>Initialize the handler.</p>
          <br/>
        </li>
        <li><code>checkPreconditions()</code>
          <p>
            This method is called to check the pre-conditions of the usecase. The pre-conditions
            are checked before the usecase is started, i.e., before the first screen is presented
            to the user. To denote that a condition does not comply, add an appropriate error message
            using <code>addErrorMessage(String)</code>. If an error message was added, the usecase
            is not started. Alternatively, you can provide information to the user using
            <code>addInfoMessage(String)</code>. This doesn't prevent the usecase from being executed.
          </p>
          <br/>
        </li>
        <li><code>lockInvolvedObjects()</code>
          <p>
            This method is called to lock all objects which could be changed during the usecase.
          </p>
          <br/>
        </li>
      </ol>
      
      <p>
        The following methods are called in a loop while the user interacts with the usecase,
        until a request parameter with the name <code>submit</code> was sent.
      </p>
      
      <ol>
        <li><code>getView()</code>
          <p>
            Requests the next view to be displayed. The view may be <code>null</code> if no
            screen should be presented to the user.
          </p>
          <br/>
        </li>
        <li><code>advance()</code>
          <p>
            This method is called to advance the usecase after the a user interaction.
            In contrast to <code>execute()</code>, this method is not called when the
            <code>&lt;input type="submit" name="submit"&gt;</code> was pressed, but for every
            other submitting of the form. A typical usecase is the <em>multiple forms editor</em> where
            <code>advance()</code> is used to update the document when the user switched to
            another element.
          </p>
          <br/>
        </li>
      </ol>
      
      <p>
        When the form is submitted using the <code>&lt;input type="submit" name="submit"&gt;</code>
        button, the usecase is finished:
      </p>
      
      <ol>
        <li><code>checkExecutionConditions()</code>
          <p>
            This method is called before the usecase is actually executed. A typical example
            is the validation of form data.
          </p>
          <br/>
        </li>
        <li><code>execute()</code>
          <p>
            This method actually executes the final step of the usecase.
          </p>
          <br/>
        </li>
      </ol>

      <p>
        When the form is submitted using the <code>&lt;input type="submit" name="cancel"&gt;</code>
        button, the usecase is cancelled:
      </p>
      
      <ol>
        <li><code>cancel()</code>
          <p>
            This method cancels the usecase. The transaction is rolled back.
          </p>
          <br/>
        </li>
      </ol>

    </section>
    
    <section>
      <title>Implementing a Custom Usecase</title>
      
      <section>
        <title>Prerequisites</title>
        <ol>
          <li>Choose a name to identify the usecase, e.g. editHeadline. It is possible to group usecases
              using "." as delimiter, for instance <code>article.editHeadline</code>.
          </li>
        </ol>
      </section>
      
      <section>
        <title>Add a Menu Item</title>
        <note>
          This step is necessary if you want to call the usecase from the Lenya menubar.
        </note>
        <ol>
          <li>Add the corresponding menu item:
            <source xml:space="preserve"><![CDATA[<item uc:usecase="article.editHeadline">Edit Headline</item>]]></source>
          </li>
        </ol>
      </section>
      
      <section>
        <title>Implement the Usecase Handler Class</title>
        <ol>
          <li>Choose a name for your business logic class, e.g. <code>org.myproject.lenya.usecases.EditHeadline</code>.</li>
          <li>The class must implement the interface <code>org.apache.lenya.cms.usecase.Usecase</code>.</li>
          <li>
            To simplify development, you can extend one of the following classes:
            <ul>
              <li><code>org.apache.lenya.cms.usecase.AbstractUsecase</code></li>
              <li><code>org.apache.lenya.cms.usecase.DocumentUsecase</code> (only for usecases invoked on document pages)</li>
              <li><code>org.apache.lenya.cms.usecase.SiteUsecase</code></li>
            </ul>
            They have built-in support for the unit-of-work pattern (which will evolve into
            an ACID transaction someday) as well as functionality specific to the area they are
            supposed to be used with, e.g. the site area.
          </li>
          <li>
            Add the usecase handler class declaration to an XPatch file, e.g. <code>$PUB_HOME/config/usecases.xconf</code>:
<source xml:space="preserve"><![CDATA[<xconf xpath="/cocoon/usecases"
       unless="/cocoon/usecases/component-instance[@name = 'article.editHeadline']">
  <component-instance name="article.editHeadline"
                      logger="lenya.usecases.editHeadline"
                      class="org.myproject.lenya.usecases.EditHeadline"/>
</xconf>]]></source>
          </li>
        </ol>
      </section>
      
      <section>
        <title>Implement the View</title>
          <p>
            The view of a usecase is optional. If you omit the view declaration, no screen is presented
            to the user. The view is declared in the usecase configuration:
          </p>
<source xml:space="preserve"><![CDATA[  <component-instance ...>
    <view template="article/editHeadline" menu="false">
      <parameter name="title" value="Edit Headline"/>
      <parameter name="..." value="..."/>
    </view>
  </component-instance>]]></source>

        <p>
          The <code>&lt;view&gt;</code> element takes an optional <code>menu</code> attribute
          which denotes if the menubar should be visible when the usecase screen is presented.
          If omitted, it defaults to <code>false</code>.
        </p>
        <p>
          The <code>&lt;view&gt;</code> element can contain an arbitrary number of <code>&lt;parameter&gt;</code>
          elements, each containing a <code>name</code> and <code>value</code> attribute. These
          parameters can be accessed in the JX template using
          <code>${usecase.getView().getParameter('...')}</code>.
        </p>
        <p>
          The view for a usecase is implemented using a JX template. The location of the
          JX template is defined using the <code>&lt;view&gt;</code> element's <code>template</code>
          attribute (relatively to the <code>usecases</code> directory, the suffix <code>.jx</code>
          is appended). The output of the view has to be a Lenya page:
        </p>
<source xml:space="preserve"><![CDATA[<page:page
  xmlns:jx="http://apache.org/cocoon/templates/jx/1.0"
  xmlns:page="http://apache.org/cocoon/lenya/cms-page/1.0"
  xmlns="http://www.w3.org/1999/xhtml"
  xmlns:i18n="http://apache.org/cocoon/i18n/2.1"    
  >

  <page:title>
    <i18n:text><jx:out value="${usecase.getView().getParameter('title')}"/></i18n:text>
  </page:title>
  <page:body>
  
    <form>
      <input type="hidden" name="lenya.continuation" value="${continuation.id}"/>
      <input type="hidden" name="lenya.usecase" value="${usecase.getName()}"/>

      ...

    </form>

  </page:body>
</page:page>]]></source>
          <p>
          Take care of adding the hidden <code>lenya.usecase</code> and <code>lenya.continuation</code> fields as shown above.
          </p>
      </section>
      
    </section>
    
    <section>
      <title>Overriding Core Usecases in Publications</title>
      
      <section>
        <title>Overriding Usecase Handler Classes</title>
      
        <p>
          The usecase resolver, which is responsible for obtaining the handler class for a usecase,
          looks first if the current publication overrides the core usecase handler.
          This can be done by declaring a usecase called <code><![CDATA[<pub-id>/<usecase-name>]]></code>,
          for instance <code>mypub/admin.addUser</code>. To implement a core usecase using a custom
          handler class, you need to
        </p>
        <ol>
          <li>Implement the handler class and put it in <code>$PUB_HOME/java/src</code>.
          In most cases, you will extend the core usecase handler class to inherit the basic functionality.</li>
          <li>
            Declare it in an <em>xpatch</em> file, for instance <code>$PUB_HOME/config/usecases.xconf</code>:
<source xml:space="preserve"><![CDATA[<xconf xpath="/cocoon/usecases" unless="/cocoon/usecases/component-instance[@name = 'mypub/admin.addUser']">
  <component-instance name="mypub/admin.addUser"
                      logger="lenya.usecases.editHeadline"
                      class="org.myproject.lenya.usecases.AddUser"/>
</xconf>]]></source>
          </li>
        </ol>
        <p>
          Now, when the usecase is invoked from inside the publication mypub, the custom
          handler class will be used.
        </p>
      </section>
      
      <section>
        <title>Overriding JX Templates</title>
        <p>
          Overriding the JX template of a usecase follows the
          <a href="../publication-templating/index.html">publication templating</a> principle.
          You just have to put a JX template with the same name in <code>$PUB_HOME/lenya/usecases</code>,
          for instance <code>$PUB_HOME/lenya/usecases/admin/addUser.jx</code>.
        </p>
      </section>
      
    </section>
    
  </body>
</document>
